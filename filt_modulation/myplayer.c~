#include <alsa/asoundlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>

char* 	path;
int 	chunk_size;
int	subchunk_size;
short 	format;
short 	channels;
int   	sample_rate;
int   	byte_rate;
short 	block_align;
short 	bits_per_sample;
int	data_size;
unsigned char *data;
double *fx;
unsigned int *x;
char* summary;
char *device = "default";
snd_output_t *output = NULL;
int filter_it,mod_band;

	
double* filtC(unsigned char *x){
		int i,j;
		double a[]={0.010000000000000,  -0.078393428001590,   0.288774700868020,  -0.655991300356510,   1.015389651389734,  -1.117379273018170,   0.884544166823302,  -0.497209314429208,  0.189949430282953,  -0.044562863221653,   0.004881218540060};
		double b[]={0.002601405638911,   0.026014056389113,   0.117063253751011,   0.312168676669361,   0.546295184171382,   0.655554221005659,   0.546295184171382,   0.312168676669361,   0.117063253751011,   0.026014056389113,   0.002601405638911};
		double prod_a,prod_b;
		int dim_a=11,dim_b=11,dim_x=data_size;
		double *fx;
		
		
	
		for(i=0;i<dim_b;i++){
		  a[i]*=100.0;
		  b[i]*=0.0001;
		}
		
		
		printf(" filtering...\n order=%d\n\n",dim_b-1);
		
		
		fx=(double*) malloc(sizeof(double)*dim_x);

		for(i=0;i<dim_b-1;i++){
		  fx[i]=0.0;
		}
		for(i=dim_b-1;i<dim_x;i++){
		  prod_a=0;
		  prod_b=0;
			
		  for(j=dim_b-1;j>=0;j--){
		    prod_b+=b[j]*x[i-j-1];
		  }
		  
		  for(j=dim_b-1;j>=1;j--){
		    prod_a+=a[j]*fx[i-j];
		  }
		  
		  fx[i]=-prod_a+prod_b;
			//printf("%f",fx[i]);
		}
		
		return fx;
}


int read_wav(int filter_it){
		FILE *fp;
		int i,j,k;
		double t=0.0,ts;
		int temp,temp2;
	
		fp=fopen(path, "rb");

		//printf("Reading wav file...\n"); // for debugging only

	
		fseek(fp,4,0);
		fread(&chunk_size, sizeof(int),1,fp); // read the chunk_size
		
		fseek(fp,16,0);
		fread(&subchunk_size, sizeof(int),1,fp); // read the Subchunk_size
		
		fseek(fp,20,0);
		fread(&format, sizeof(short),1,fp); // read the file format.  This should be 1 for PCM

		fseek(fp,22, 0);
		fread(&channels, sizeof(short),1,fp); // read the # of channels (1 or 2)

		fseek(fp,24, 0);
		fread(&sample_rate, sizeof(int),1,fp); // read the sample_rate

		fseek(fp,28, 0);
		fread(&byte_rate, sizeof(int),1,fp); // read the byte_rate

		fseek(fp,32, 0);
		fread(&block_align, sizeof(short),1,fp); // read the block_align

		fseek(fp,34, 0);
		fread(&bits_per_sample, sizeof(short),1,fp); // read the bits_per_sample

		fseek(fp,40, 0);
		fread(&data_size, sizeof(int),1,fp); // read the size of the data

	
		fseek(fp,40,0);
		fread(&data_size, sizeof(int),1,fp); // read the size of the data
		
		data = (char*)malloc(sizeof(char)*data_size);
		fseek(fp,44,0);
		fread(data, sizeof(unsigned char),data_size,fp);		// read the data chunk

		fclose(fp); // close the input file
		
		ts=1.0/(double)sample_rate;						
		if(filter_it){

		  if(mod_band){
		    for(i=0;i<data_size;i++){
		      data[i]=(unsigned char)(128.0+(double)(data[i]-128)*cos(2*M_PI*10000*t));
		    
		      t+=ts;
		    }
		  }
		  
		  fx=filtC(data);
		  
		  for(i=0;i<data_size;i++){
		    data[i]=(unsigned char)fx[i] ;
		  }
		}
		k=0;
		x= (unsigned int*)malloc(sizeof(unsigned int)*data_size/4);
		for(i=0;i<data_size/4;i++){
		  x[i]=0;
		  for(j=0;j<4;j++){
		    x[i]+=((unsigned int)(data[k]))<<(8*j);
		    k++;
		  }
		}
		
		
		
		return 1;
}

int save_wav(char* outpath){
		FILE *fp;
	
		fp=fopen(outpath, "wb+");

		// write the wav file per the wav file format
		fwrite ("RIFF",sizeof(char),4,fp);
		fwrite (&chunk_size, sizeof(char),4,fp);
		fwrite ("WAVE",sizeof(char),4,fp);
		fwrite ("fmt ",sizeof(char),4,fp);
		fwrite (&subchunk_size,sizeof(char),4,fp);
		fwrite (&format,sizeof(char),2,fp);
		fwrite (&channels,sizeof(char),2,fp);
		fwrite (&sample_rate,sizeof(char),4,fp);
		fwrite (&byte_rate,sizeof(char),4,fp);
		fwrite (&block_align,sizeof(char),2,fp);
		fwrite (&bits_per_sample,sizeof(char),2,fp);
		fwrite ("data",sizeof(char),4,fp);
		fwrite (&data_size,sizeof(char),4,fp);
		fwrite (x,sizeof(char),data_size,fp);

		fclose(fp);
		return 1;
}

char *getSummary(){
		printf(" format: %d\n channels: %d\n sample_rate: %d\n byte_rate: %d\n block_align: %d\n bits_per_sample: %d\n data_size: %d\n", format, channels, sample_rate, byte_rate, block_align, bits_per_sample, data_size);
}



int main( int argc, char *argv[] ){
	int err;
        unsigned int i;
        snd_pcm_t *handle;
        snd_pcm_sframes_t frames;
	char outpath[51];
	
	if (argc < 3) {
		printf("usage: %s <filename> <filter it (0-1)> [<get higher>]\n",argv[0]);
		return 0;
	}
	path=argv[1];
	filter_it=0;
	mod_band=0;
	if(argc>=3 && strcmp(argv[2],"1")==0){
		filter_it=1;
		if(argc>3 && strcmp(argv[3],"1")==0){
		  mod_band=1;
		}
	       
	}
        
	//read_wav(1);
	//scanf("%s",outpath);
	//save_wav(outpath);
	
	read_wav(filter_it);
	//scanf("%s",outpath);
	//save_wav(outpath);
	
	getSummary();
	
	if ((err = snd_pcm_open(&handle, device, SND_PCM_STREAM_PLAYBACK, 0)) < 0) {
		printf("Playback open error: %s\n", snd_strerror(err));
		exit(EXIT_FAILURE);
	}
	if ((err = snd_pcm_set_params(handle,SND_PCM_FORMAT_U8,SND_PCM_ACCESS_RW_INTERLEAVED,1,44100,1,0)) < 0) {
			printf("Playback open error: %s\n", snd_strerror(err));
			exit(EXIT_FAILURE);
	}

	for (i = 0; i <data_size/4; i++) {
		
		frames = snd_pcm_writei(handle,&x[i],4);
		/*
		if (frames < 0){
			frames = snd_pcm_recover(handle, frames, 0);
			printf("recov\n");
		}
		if (frames < 0) {
			printf("snd_pcm_writei failed: %s\n", snd_strerror(err));
			break;
			}
		if (frames > 0 && frames < (long)sizeof(x)) printf("Short write (expected %li, wrote %li)\n", (long)sizeof(x), frames);
		//printf("%d\n",i);
		*/
	}
	snd_pcm_close(handle);



	return 0;
}
